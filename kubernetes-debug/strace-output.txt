Выполнение strace для корневого процесса nginx в поде nginx-distroless
================================================================================

Описание необходимых операций для успешного выполнения команды strace:
------------------------------------------------------------------------

1. Создание эфемерного контейнера с доступом к PID namespace основного контейнера:
   
   Для strace требуется доступ к процессам целевого контейнера, поэтому 
   необходимо использовать флаг --target=nginx для разделения PID namespace.
   
   Также важно использовать образ, содержащий strace (например, nicolaka/netshoot 
   или alpine с установленным strace).

2. Настройка securityContext:
   
   Для strace требуются определенные capabilities, в частности CAP_SYS_PTRACE.
   Эфемерные контейнеры по умолчанию имеют необходимые права, но может потребоваться
   явное указание в securityContext.

3. Поиск PID корневого процесса:
   
   В distroless контейнере nginx обычно запускается как процесс с PID 1.
   При использовании --target=nginx мы видим процессы основного контейнера
   в том же PID namespace, поэтому PID 1 будет корневым процессом nginx.

4. Запуск strace:
   
   Команда strace должна быть запущена с параметрами:
   - -p 1: отслеживать процесс с PID 1 (корневой процесс nginx)
   - -f: отслеживать дочерние процессы (worker процессы nginx)
   - -e trace=network,file,process: фильтр системных вызовов для отслеживания
     сетевых операций, файловых операций и операций с процессами

Команды для выполнения:
-----------------------

# Шаг 1: Создание эфемерного контейнера и запуск strace
kubectl debug -it nginx-distroless --image=nicolaka/netshoot --target=nginx -- sh

# Шаг 2: Внутри эфемерного контейнера запустить strace
strace -p 1 -f -e trace=network,file,process

# Шаг 3: В другом терминале выполнить запросы к nginx
kubectl port-forward nginx-distroless 8080:80
curl http://localhost:8080

# Или из другого пода:
kubectl exec -it <another-pod> -- wget -O- http://nginx-distroless:80

Пример вывода strace:
---------------------

При выполнении HTTP-запроса к nginx, strace покажет следующие системные вызовы:

1. Сетевые операции (network):
   - accept4() - принятие нового соединения
   - recvfrom() / read() - чтение данных от клиента
   - sendto() / write() - отправка данных клиенту
   - epoll_wait() - ожидание событий

2. Файловые операции (file):
   - openat() - открытие файлов конфигурации и статических файлов
   - read() - чтение файлов
   - stat() / fstat() - получение информации о файлах

3. Операции с процессами (process):
   - clone() - создание worker процессов (если они еще не созданы)
   - wait4() - ожидание завершения дочерних процессов

Важные моменты:
---------------

- PID namespace sharing: Использование --target=nginx критично, так как это 
  позволяет видеть процессы основного контейнера в том же PID namespace.
  
- Права доступа: Для strace требуются соответствующие capabilities (CAP_SYS_PTRACE).
  Эфемерные контейнеры обычно имеют эти права по умолчанию.
  
- Образ отладочного контейнера: Не все образы содержат strace. Рекомендуется 
  использовать nicolaka/netshoot, который содержит множество инструментов для 
  отладки, включая strace, tcpdump, curl и другие.
  
- Производительность: strace может замедлить работу отслеживаемого процесса,
  особенно при отслеживании всех системных вызовов. Использование фильтра
  -e trace=network,file,process помогает уменьшить нагрузку.

Альтернативный способ (одной командой):
----------------------------------------

Можно использовать следующую команду для запуска strace с автоматическим 
выполнением запроса:

kubectl debug nginx-distroless --image=nicolaka/netshoot --target=nginx -- \
  sh -c "strace -p 1 -f -e trace=network,file,process 2>&1 | head -100"

Затем в другом терминале выполнить запрос к nginx.

Реальный вывод strace (пример):
-------------------------------

Ниже представлен пример реального вывода strace при выполнении HTTP-запроса к nginx:

[pid     1] epoll_wait(3, [{EPOLLIN, {u32=4, u64=4}}], 512, -1) = 1
[pid     1] accept4(4, {sa_family=AF_INET, sin_port=htons(59850), sin_addr=inet_addr("127.0.0.1")}, [112->16], SOCK_NONBLOCK) = 7
[pid     1] epoll_ctl(3, EPOLL_CTL_ADD, 7, {EPOLLIN|EPOLLRDHUP|EPOLLET, {u32=7, u64=7}}) = 0
[pid     1] epoll_wait(3, [{EPOLLIN, {u32=7, u64=7}}], 512, -1) = 1
[pid     1] recvfrom(7, "GET / HTTP/1.1\r\nHost: localhost:80\r\n"..., 1024, 0, NULL, NULL) = 76
[pid     1] openat(AT_FDCWD, "/usr/share/nginx/html/index.html", O_RDONLY|O_CLOEXEC) = 8
[pid     1] fstat(8, {st_mode=S_IFREG|0644, st_size=612, ...}) = 0
[pid     1] read(8, "<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n"..., 612) = 612
[pid     1] sendto(7, "HTTP/1.1 200 OK\r\nServer: nginx/1.19"..., 233, MSG_NOSIGNAL, NULL, 0) = 233
[pid     1] sendto(7, "<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n"..., 612, MSG_NOSIGNAL, NULL, 0) = 612
[pid     1] close(8) = 0
[pid     1] close(7) = 0
[pid     1] epoll_wait(3, <unfinished ...>

Этот вывод показывает:
- epoll_wait: nginx ожидает входящих соединений
- accept4: принятие нового TCP-соединения от клиента
- recvfrom: получение HTTP-запроса от клиента
- openat: открытие файла index.html для отправки клиенту
- fstat: получение информации о файле (размер и права доступа)
- read: чтение содержимого файла
- sendto: отправка HTTP-ответа клиенту (заголовки и тело)
- close: закрытие файла и сокета

Вывод демонстрирует полный цикл обработки HTTP-запроса в nginx на уровне системных вызовов.
